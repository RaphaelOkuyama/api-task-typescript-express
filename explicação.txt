https://onebitcode.notion.site/B-nus-API-usando-Express-e-TypeScript-d7fd1086aee5462e9cb20a55b82c04c1

1. Criação do Projeto e Instalação das Dependências
O primeiro passo é criar o projeto Node.js e instalar as dependências necessárias. Você faz isso com os comandos:

bash
npm init -y
npm install --save express zod
npm install --save-dev @types/node @types/express typescript tsx
express: framework para criar servidores HTTP (API).

zod: biblioteca para validação de dados.

Os pacotes @types/node e @types/express são tipos para o TypeScript entender essas libs.

typescript é o compilador TypeScript.

tsx facilita rodar arquivos TypeScript diretamente no desenvolvimento.

2. Ajustando Scripts no package.json e Configuração do TypeScript
No package.json, adicionamos scripts para facilitar o desenvolvimento e produção:

json
"scripts": {
  "dev": "tsx watch src/server.ts",
  "build": "tsc",
  "start": "node build/server.js"
}
"dev": roda o servidor em modo de desenvolvimento com hot reload.

"build": compila o TypeScript para JavaScript.

"start": roda o projeto já compilado para produção.

No tsconfig.json, configuramos o compilador:

json
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./build"
  }
}
Principais opções:

"strict": true ativa checagem estrita de tipos.

"outDir": "./build" define onde será gerado o código compilado.

3. Modelagem da Entidade (Model) Task
Aqui criamos o modelo da entidade principal, chamada Task (tarefa), que representa cada item a ser gerenciado na API.

Interface e Classe
typescript
interface TaskAttributes {
  id: number;
  title: string;
  description: string;
  status: "todo" | "doing" | "done";
  priority: "low" | "medium" | "high";
  createdAt: Date;
  updatedAt: Date;
}
Interface define o formato dos dados da tarefa.

A classe Task implementa lógica de CRUD em memória (os dados não ficam salvos se reiniciar):

typescript
export class Task {
  private static tasks: Task[] = [];
  private static sequence: number = 1;
  ...
}
static tasks: array que armazena todas as tarefas criadas.

static sequence: incrementa automaticamente o id de cada tarefa nova.

Métodos da Task
findAll: retorna todas as tarefas.

findById(id): busca tarefa pelo id.

create(attributes): cria e armazena nova tarefa.

update(id, attributes): atualiza atributos da tarefa.

delete(id): remove a tarefa pelo id.

Esses métodos abstraem toda a manipulação dos dados. Não precisamos mexer no array direto em outras partes do sistema.

4. Classe de Erro Personalizado (HttpError)
Criamos uma classe para padronizar erros HTTP:

typescript
export class HttpError extends Error {
  status: number;
  constructor(status: number, message: string) {
    super(message);
    this.status = status;
  }
}
Assim podemos lançar, por exemplo, throw new HttpError(404, "task not found"), facilitando o tratamento desses erros na aplicação.

5. Controller (TaskController)
O Controller recebe a requisição, processa e retorna resposta.

typescript
import { Handler, Request, Response } from "express";
import { Task } from "../models/Task";
import { HttpError } from "../errors/HttpError";
import { z } from "zod";
Aqui usamos zod para validar o corpo das requisições, garantindo que os dados recebidos estejam no formato certo antes de processar.

Schemas de Validação
typescript
const StoreRequestSchema = z.object({
  title: z.string(),
  description: z.string(),
  status: z.enum(["todo", "doing", "done"]),
  priority: z.enum(["low", "medium", "high"])
});
Garante que o POST de uma tarefa nova tem todos os campos certos.

Métodos
index: lista todas as tarefas.

store: cria tarefa nova.

show: exibe tarefa por id.

update: atualiza uma tarefa.

delete: remove tarefa.

Todos usam a model Task para executar a lógica.

6. Definindo as Rotas (routes)
Criamos o roteador do Express para conectar as rotas aos métodos do controller:

typescript
import { Router } from "express";
import { TaskController } from "./controllers/TaskController";

const router = Router();
const taskController = new TaskController();

router.get("/tasks", taskController.index);
router.post("/tasks", taskController.store);
router.get("/tasks/:id", taskController.show);
router.put("/tasks/:id", taskController.update);
router.delete("/tasks/:id", taskController.delete);

export { router };
Rotas bem RESTful, cada uma para um tipo de operação com tarefas.

7. Middleware de Tratamento de Erros
Padroniza as respostas de erro da API:

typescript
import { ErrorRequestHandler } from "express";
import { HttpError } from "../errors/HttpError";

export const errorHandler: ErrorRequestHandler = (err, req, res, next) => {
  if (err instanceof HttpError) {
    res.status(err.status).json({ message: err.message });
  } else if (err instanceof Error) {
    res.status(500).json({ message: err.message });
  } else {
    res.status(500).json({ message: "internal server error" });
  }
}
8. Arquivo Principal do Servidor
Aqui juntamos tudo e subimos o servidor Express:

typescript
import express from "express";
import { router } from "./routes";
import { errorHandler } from "./middlewares/error-handler";

const app = express();

app.use(express.json());        // habilita JSON no body

app.use("/api", router);       // todas as rotas de tarefas ficam em /api

app.use(errorHandler);         // tratamento global de erros

const PORT = 3000;
app.listen(PORT, () => console.log(`Servidor iniciado em http://localhost:${PORT}/`));
Resumo do Fluxo
Requisição chega em /api/tasks (ou /api/tasks/:id)

Validação do corpo usando zod

Controller recebe e chama o método correto do Model

Model executa o CRUD em memória

Resposta enviada ao cliente

Se algo der errado, o middleware de erro cuida e envia mensagem adequada

Dúvidas ou Exemplos?
Se você quiser que eu explique algum trecho com mais profundidade ou mostre exemplos de uso de algum endpoint, só pedir!

Se quiser ver exemplos de requisições (usando Postman, curl, etc), ou quer que eu explique sobre testes, autenticação, integração com banco de dados, ou qualquer outra dúvida, pode perguntar.

Quer um exemplo prático de requisição ou explicação de código? É só falar qual ponto!